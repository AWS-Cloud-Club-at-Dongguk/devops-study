Q. 안정 해시 링을 직접 코드로 구현한다면, '링'이라는 원형 공간과 그 위의 노드 위치를 어떤 자료구조로 관리하는 것이 가장 효율적일까요? <br>
A. “안정 해시 링”에서 핵심 연산:   <br>
(1) 주어진 해시 값의 ‘다음(시계방향) 노드’ 찾기, (2) 노드(또는 가상노드) 다건 추가/삭제, (3) 정렬 순회 <br>
-> 정렬 상태를 보장하면서 다음 원소를 찾을 수 있는 자료구조가 적합 <br>
-> 균형 트리 기반의 “정렬 맵(Ordered Map)” <br>
- 정렬 맵(Ordered Map)에 표현하는 방식
    - 메모리 안에서는 진짜 원형 자료구조를 만들지 않음
    - 해시 키, 서버 위치 따로 저장
    - 정렬 맵이 자동으로 키들을 오름차순 정렬된 선형 구조로 관리
        - 해시키로 나온 값보다 큰 첫 번째 키를 찾으면 → 시계 방향 다음 노드
        - 만약 큰 키가 없다면 → 정렬 맵의 첫 번째 키를 선택 → 링이기 때문에 원점(0)으로 돌아간 효과
```
정렬 맵(Ordered Map)
 ```

Q. 안정 해시에서 말하는 노드는 AWS 환경에서 어떤 리소스에 해당될 수 있을까요? <br>
A. 키를 저장하거나 요청을 처리하는 저장소/서버 단위 = 노드 <br>
- 이 해시 함수를 사용하면 서버 IP 나 이름을 이 링 위의 어떤 위치에 대응시킬 수 있다. (교안)
- 키를 기준으로 데이터를 분산시켜야 하는 모든 단위 리소스
    - DB 서버, 캐시 서버, 애플리케이션 서버, 세션 서버, 샤드 등
    - ex)  캐시 서버: Redis / Memcached 인스턴스
```
분산 환경에서 키를 나눠 담당할 수 있는 모든 리소스
 ```

--- 

Q. 로드 밸런서도 트래픽을 균등하게 나눠주는데, 안정 해시를 별도로 사용하는 이유는?<br>
A. 분산이라는 점에서 동일하지만 방식과 목적이 다름 <br>
- 로드 밸런서의 목적 : 실시간 요청 트래픽을 여러 웹 서버로 분산 → 서버 과부하 방지.<br>
- 안정 해시의 목적 : 데이터나 세션 같은 상태를 특정 서버에 고정적으로 매핑<br>
    - 동일한 키 → 항상 동일한 노드라는 일관성을 유지 (변화가 생길 시 일부만 재배치)
- 웹 서버의 요청은 무상태로 설계하는 경우가 많아서 로드 밸런서만으로 충분
- sticky session이 필요한 경우 일반 로드 밸런서도 안정 해시와 함께 씀
    - 개념: 세션/유저 ID를 해시 링에 매핑해서 특정 서버에 고정
    - 구현 방식 : 해시 링 위에 서버를 배치

```
목적과 방식이 다름
 ```


Q. 안정 해시를 적용한 것과 로드 밸런서의 Sticky Session 방식은 어떤 차이가 있을지?<br>
A. Sticky Session : 클라이언트로부터의 요청은 항상 같은 서버로 전송
- Sticky Session = 개념
- 안정 해시 = Sticky Session을 더 확장성 있고 안정적으로 구현하는 기법
- Sticky Session 구현 방법
    - 쿠키 기반 (LB가 심은 세션 쿠키로 라우팅)
    - IP 해시 기반 (hash(IP) % N)
    - 세션 매핑 테이블 기반 (LB가 테이블 관리)
    - 안정 해시 링에서 서버 매핑
```
Sticky Session 방식의 대표 구현 방법이 안정 해시이다. 
 ```

Q. 가상 노드도 서버 당 100개씩 두려면 해시 링을 저장하기 위한 자료 구조 비용이 더 클 것 같은데, 유사한 목적(재배치 최소화, 균등 분산)을 가지면서도 더 간단한 방법은 없는지?<br>
A. 해시 분배 알고리즘를 변경
- Rendezvous Hashing (HRW)
    - 방법: 키마다 모든 서버에 점수를 매겨 가장 높은 서버 선택
    - 장점: 링/가상노드 불필요, 가중치(서버별 capacity) 쉽게 지원, 재배치 ≈ 1/N
- Jump Consistent Hash
    - 방법: key와 파티션 개수 N만으로 O(1)에 가까운 계산으로 대상 파티션 결정
    - 장점: 자료구조/메모리 0, 매우 빠름, 서버 증감 시 재배치 ≈ 1/N
- 등등
- 단점 : 직관성 떨어짐, O(N) 계산 (서버 수 많으면 부담)
```
다양한 해시 분배 알고리즘 존재
 ```

---
Q. 실제 시스템에서 서버가 추가되거나 삭제될 때, 키의 재분배가 자동으로 일어나는 것인지 직접 코드로 구현해야 하는 것인지 궁금합니다.<br>
A. 
- 직접 코드로 구현하는 경우
    - 분산 캐시/DB 클라이언트 라이브러리 안에서 안정 해시가 들어있음.
- 로드밸런서/인프라 레벨에서 제공하는 경우
    - ex) 캐시 서버 EC2 인스턴스를 늘림 → 서비스 디스커버리(Consul, etcd, Eureka 등)가 노드 목록 업데이트 → 클라이언트 드라이버나 LB가 새로운 링을 계산해서 라우팅 시작.
- 직접 안정 해시 알고리즘을 짜는 일은 거의 없음
```
이 기능을 제공하는 리소스를 활용해서 설계/설정
 ```

Q. 서버가 추가되거나 삭제되어 키의 목적지가 바뀌면 캐시 미스가 실제로 발생하는지, 이를 완화하거나 방지할 수 있는 방법은 없는지 궁금합니다.<br>
A. 바뀐 키는 새 서버에 데이터가 없으니 → 캐시 미스 발생
- 완화 방법 : 중복 저장(각 키를 하나의 서버에만 두지 않고, 여러 노드에 중복 저장해둠), 백그라운드 리밸런서(서버 증감 이벤트가 발생하면, 백그라운드에서 키를 점진적으로 옮기는 작업을 실행) 등등
    - 메모리/네트워크 비용 증가
- 보통은 그냥 캐시 미스 허용 → 새 서버에 채워 넣는 방식
```
완화 방법 존재하지만 보통 캐시 미스 허용
 ```

---
Q. 1주차 설계도에서 보여진 여러 대의 캐시가 있는 경우가 있었는데, 동일한 역할을 하는 캐시 서버가 여러 대 존재한다는 것 == 캐시 샤딩이 맞을까 ?<br>
A. 캐시 서버가 여러 대 존재한다고 해서 항상 캐시 샤딩은 아니다
- 복제 : 모든 캐시 서버가 같은 데이터를 그대로 저장
- 샤딩 : 캐시 서버마다 데이터를 나눠서 저장
```
항상 캐시 샤딩은 아니다
 ```

---
Q. 안정 해시에서 파티션의 크기를 균등하게 유지하는 게 불가능한 것이 단점이라 하였는데, 이게 왜 단점이 되는지 궁금합니다. 구체적으로 어떤 문제점 때문에 단점인건가요?<br>
- 부하 불균형
    - 요청 또는 데이터를 서버에 균등하게 나누는 것이 중요 -> 위반
- 파티션이 균등하지 않으면 특정 서버 장애 시 큰 구간이 한꺼번에 이동 → 장애 복구 비용 커짐
```
안정 해시를 사용하는 목적 달성 불가 
 ```

Q. SHA-1 함수에 대한 설명이 자세히 안나와 있는데 이 함수가 어떤 함수인지 궁금합니다.<br>
- 해시 함수 SHA-1 : 입력 데이터 → 고정 길이 해시 값 출력
- SHA-1은 그냥 큰 범위의 숫자 공간(0 ~ 2^160-1)을 제공
```
큰 범위의 숫자 칸을 제공하는 함수
 ```